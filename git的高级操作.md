# Git的高级操作
## Git钩子
和其它版本控制系统一样，Git 能在特定的重要动作发生时触发自定义脚本。 有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 你可以随心所欲地运用这些钩子。
**Git hooks**是git在工作流程的特定重要动作发生时触发的自定义脚本。有两组这样的钩子：客户端的和服务端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务端钩子作用与诸如接收被推送的提交这样的联网操作。
### 客户端钩子
客户端钩子分好几种，比较常用的有`pre-commit`, `commit-msg`, `pre-push`和`pre-rebase`.
1. `pre-commit`钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit --no-verify 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 lint 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。
2. `commit-msg`钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。
3. `pre-push`钩子会在 git push 运行期间，更新了远程引用但尚未传送对象时被调用。它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。
4. `pre-rebase`钩子会在变基之前运行，已非零退出可以中止变基的过程。你可以使用这个钩子来禁止对那些已经进行过推送的提交变基。Git自带的`pre-rebase`钩子示例就是这么做的。
### 服务端钩子
服务端的钩子相对来说比较少，比较有用的有`pre-receive`和`post -receive`。
1. `pre-receive`在处理来自客户端的推送之前运行，如果该钩子已非零值退出，则这次推送失败，所有的推送内容都不会被接收。
2. `post-receive`这个钩子在整改推送结束后运行，经常用来在推送完成后更新其他系统服务或者通知用户。他的用途包括给某个邮件列表发信，通知持续集成的服务器或者是更新问题追踪系统，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。
### 怎么写一个Git Hook？
**Git Hook**在`.git`的`hooks`目录下

## 分支
### 分支是什么？
在git中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照（snapshot）的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先, 而**分支**就是指向这个提交对象的一个可变指针,分支在多次提交之后就连成了一条线，就像河流一样。
![分支][]
git的分支是一个很方便的功能， 它可以提交我们的开发的效率和灵活度，在git上创建分支非常简单，使用`git branch branchname`就可以创建一个分支，使用`git checkout -b [branchname]`可以创建一个分支并直接切换到该新创建的分支上面去。
为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交地文件。暂存操作会为每一个文件计算校验和，然后会把当前版本地文件快照保存到git仓库（git使用blob对象来保存它们）最终将校验和加入到缓存区等待提交：
``` bash
git add README test.rb LICENSE
git commit -m 'The initial commit of my project'
```
Git的分支，其实本质上仅仅是指向提交对象的**可变指针**，Git的默认分支名字是*master*。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的*master*分支。 它会在每次的提交操作中**自动向前**移动。

> Git的"master"分支并不是一个特殊分支，它就跟其他分支完全没有区别。

### 分支创建
创建一条分支很简单，使用`git branch`命令就可以了，因为它实际上只是创建了一个可移动的指针，所以这个过程是非常迅速的，比如你要创建一个`testing`分支并切换到这个分支:
```
git branch testing
```
![创建分支](https://git-scm.com/book/en/v2/images/two-branches.png)
你可以简单的使用`git log`命令查看各个分支当前所指的对象.提供这一功能的参数是--decorate。
### 分支切换
要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：
```
git checkout testing
```
这样就把HEAD指针指向了testing分支。
![切换分支至testing](https://git-scm.com/book/en/v2/images/head-to-testing.png)
### 合并分支
在我们开发完一个独立功能或者修复一个bug之后，需要将创建的这个分支的代码合并到我们签出的分支上，从而完成这个任务。
首先我们要保证这个分支上开发的代码都已经被提交了，然后通过`git checkout`切换回我们签出的分支，然后通过`git merge <branchName>`合并我们提交的分支,merge会有两种情况：
1. 第一种是**fast forward**,这种情况是在你要合并的分支领先于与当前分支，这种方式不会创建一个新的提交记录，而是将`HEAD`指向目标分支上最后一次提交，通过这种方式合并，git的提交记录会是一条直线，就像你在当前分支上进行了提交一样。
例如：我们创建了一个新分支**feature1**,增加了一个新文件a.js并提交，然后切换到**master**分支，并进行合并，因为在master分支上没有进行其他的提交，git会默认使用**fast forward**的方式合并(`git merge feature1`)，这种方式git只需要简单地将HEAD指向**feature2**分支上的最后一次提交就可以了。
    ```
    git log --oneline --graph
    * c3219a1(feature1) new a.js
    * ebbb5a0(master)
    ```
2. 第一种合并方式会在当前分支上合并目标分支上的代码，并创建一次新的提交,这种方式我们需要使用`--no-ff`参数。
例如：我们创建一个新分支**feature2**,增加一个新文件b.js并提交，然后切换回`master`分支合并**feature2**分支(`git merge feature2 --no-ff`)
    ```
    git log --oneline --graph
    * ebbb5a0(HEAD -> master) Merge branch 'feature2'
    |\
    | *7ec8a26 (feature2) new b.js
    |/
    * 4e207c1(master)
    ```
### 删除分支
为了避免在本地上存在太多的分支，我们在开发完一个分支并且合并到目标分支上之后，该分支就可以被删除掉了，使用命令`git branch -d <branchName>`就可以删除掉一个，如果该分支上的内容还没有被合并到当前的分支，会提示无法删除该分支，这个时候可以使用`git branch -D <branchName>`参数强制删除该分支。
### 变基
分支合并除了`merge`之外还有一种方式`rebase`，在进行`rebase`时,git会比较当前分支和目标分支，找到他们共同的祖先（即两个分支的共同的一次提交），然后提取当前分支上从该共同祖先提交以来的历次提交，将他们存为一个临时文件，然后以指定的目标分支的指定提交为基底，将这个提取出来的临时文件添加到该指定基底之后。这种方式的合并结果与**merge**没有任何区别，但是变基使得提交历史更加整洁。你在查看提交历史记录的时候会发现，尽管你的分支和其他人的分支是同时进行开发的，但是**rebase**后的提交记录像一条直线，就好像你们是串行地进行开发一样。如图一：
![图一](https://git-scm.com/book/en/v2/images/basic-rebase-1.png)
然后进行一般的合并(merge)如图二：
![图二](https://git-scm.com/book/en/v2/images/basic-rebase-2.png)
通过这种方式进行的合并提交历史记录会有分叉，如果通过变基的方式来合并分支，得到的历史记录还是会像一条直线。
执行命令`git rebase master`,git会帮我们把expriment分支上多出的提交记录提取出来，然后以master分支最后一次提交为基底，将这些提取出来的提交记录放在master分支之后。如图三：
![图三](https://git-scm.com/book/en/v2/images/basic-rebase-3.png)
最后，我们只需切换到master分支上（`git checkout master`），再合并experiment分支即可（`git merge experiment`）,这样得到的master分支的提交记录如图四:
![图四](https://git-scm.com/book/en/v2/images/basic-rebase-4.png)
> **注意：**一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。

## 临时存储
有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。针对这个问题的答案是 git stash 命令。
### 储存工作
使用`git stash`命令可以临时存储当前未提交的内容。
### 恢复工作
在切换完分支并且工作结束后，再切换到先前切出的分支使用`git stash apply`命令可以恢复临时存储的内容。默认情况下，Git会将最近一次的临时存储内容恢复，如果你想指定恢复的内容，可以先通过`git stash list`列出所有的存储内容，一般会是这样：
```
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
```
然后再通过`git stash apply stash@{index}`就可以恢复指定索引的临时存储，通过这样的方式恢复的临时存储。
### 创造性的临时存储
有几个储藏的变种可能也很有用。 第一个非常流行的选项是 stash save 命令的 --keep-index 选项。 它告诉 Git 不要储藏任何你通过 git add 命令已暂存的东西。
当你做了几个改动并只想**提交**其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。
另一个经常使用储藏来做的事情是像储藏跟踪文件一样储藏未跟踪文件。 默认情况下，git stash 只会储藏已经在追踪中的文件。 如果指定 --include-untracked 或 -u 标记，Git 也会储藏任何创建的未跟踪文件。
### 删除临时存储
使用`git drop`可以删除一个临时存储

## cherry-pick
`cherry-pick`命令用于选择指定某一分支中一个或几个提交来进行操作。例如我们有两个分支master和feature，feature有一个提交增加了一个`y.js`文件，我们想要将这个提交合并到我们的`master`分支上，但是在这个提交之前所有的提交我们都不需要，这个时候我们就可以用到了`cherry-pick`这个命令。

